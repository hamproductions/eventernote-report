# CLAUDE.MD - REFERENCE PATTERNS DOCUMENTATION

**CRITICAL**: This file contains ALL exact patterns extracted from reference projects. Follow these patterns EXACTLY, not approximations.

Reference Projects:
- `/Users/vittayapalotai.tanyawat/code/eventernote-report/.sample-react-project`
- `/Users/vittayapalotai.tanyawat/code/hamflow`

---

## 1. FILE STRUCTURE

```
project-root/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ ui/              # Ark UI styled components
â”‚   â”‚   â””â”€â”€ [feature]/       # Feature-specific components
â”‚   â”œâ”€â”€ contexts/            # React Context providers
â”‚   â”œâ”€â”€ hooks/              # Custom React hooks
â”‚   â”œâ”€â”€ pages/              # Vike pages
â”‚   â”‚   â”œâ”€â”€ +config.ts      # Global Vike config
â”‚   â”‚   â”œâ”€â”€ +Layout.tsx     # Root layout
â”‚   â”‚   â””â”€â”€ [route]/
â”‚   â”‚       â””â”€â”€ +Page.tsx
â”‚   â”œâ”€â”€ server/             # Backend code
â”‚   â”‚   â”œâ”€â”€ index.ts        # Elysia server entry
â”‚   â”‚   â”œâ”€â”€ routes/         # API routes
â”‚   â”‚   â”œâ”€â”€ services/       # Business logic
â”‚   â”‚   â””â”€â”€ crawlers/       # Web scraping
â”‚   â”œâ”€â”€ shared/             # Shared types/utils
â”‚   â””â”€â”€ index.css           # Global styles
â”œâ”€â”€ styled-system/          # Generated by PandaCSS
â”œâ”€â”€ public/                 # Static assets
â”œâ”€â”€ vite.config.ts
â”œâ”€â”€ panda.config.ts
â””â”€â”€ package.json
```

---

## 2. IMPORT ORDER (CRITICAL)

```typescript
// 1. Node built-ins
import { join } from 'path';

// 2. External libraries
import { Elysia } from 'elysia';
import { useQuery } from '@tanstack/react-query';

// 3. Vike imports
import { renderPage } from 'vike/server';

// 4. React imports
import React, { useState } from 'react';

// 5. Styled-system imports (PandaCSS)
import { Box, VStack, HStack } from 'styled-system/jsx';

// 6. UI component imports
import { Button } from '~/components/ui/button';

// 7. Context/Hook imports
import { useAuth } from '~/contexts/AuthContext';

// 8. Type imports
import type { User } from '~/types/user';

// 9. CSS imports
import '~/index.css';
```

---

## 3. VITE CONFIG (EXACT PATTERN)

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import vike from 'vike/plugin';
import tsconfigPaths from 'vite-tsconfig-paths';
import { join } from 'path';
import { fileURLToPath } from 'url';

const __dirname = fileURLToPath(new URL('.', import.meta.url));

export default defineConfig({
  plugins: [
    tsconfigPaths(),
    react({
      babel: {
        plugins: [['babel-plugin-react-compiler', {}]]
      }
    }),
    vike()
  ],
  resolve: {
    alias: {
      '~': join(__dirname, './src'),
      'styled-system': join(__dirname, './styled-system')
    }
  },
  build: {
    outDir: 'dist/client'
  }
});
```

---

## 4. PANDA CONFIG (EXACT PATTERN)

```typescript
// panda.config.ts
import { defineConfig } from '@pandacss/dev';
import { createPreset } from '@park-ui/panda-preset';
import blue from '@park-ui/panda-preset/colors/blue';
import neutral from '@park-ui/panda-preset/colors/neutral';

export default defineConfig({
  preflight: true,

  presets: [
    '@pandacss/preset-base',
    createPreset({
      accentColor: blue,
      grayColor: neutral,
      radius: 'md'
    })
  ],

  include: ['./src/**/*.{js,jsx,ts,tsx}'],
  exclude: [],

  jsxFramework: 'react',
  outdir: './styled-system',

  importMap: {
    css: 'styled-system/css',
    recipes: 'styled-system/recipes',
    patterns: 'styled-system/patterns',
    jsx: 'styled-system/jsx'
  }
});
```

---

## 5. ELYSIA SERVER (EXACT PATTERN)

```typescript
// src/server/index.ts
import { join } from 'path';
import { Elysia } from 'elysia';
import { cors } from '@elysiajs/cors';
import { staticPlugin } from '@elysiajs/static';
import { logger } from '@bogeychan/elysia-logger';
import { connect } from 'elysia-connect-middleware';
import { renderPage } from 'vike/server';
import { db } from '../db';
import { eventRoutes, statsRoutes, healthRoute } from './routes';

const PORT = process.env.PORT || 3002;
const isProduction = process.env.NODE_ENV === 'production';
const root = process.cwd();

const app = new Elysia();

// Setup Vike dev middleware in development
if (!isProduction) {
  const { createDevMiddleware } = await import('vike/server');
  const { devMiddleware } = await createDevMiddleware({ root });
  app.use(connect(devMiddleware));
} else {
  // In production, serve static assets
  app.use(
    staticPlugin({
      assets: join(root, 'dist', 'client'),
      prefix: '/'
    })
  );
}

app
  // Middleware
  .use(logger())
  .use(cors({ credentials: true }))

  // Global state
  .decorate('db', db)

  // Health check
  .use(healthRoute)

  // API routes
  .group('/api', (api) =>
    api
      .use(eventRoutes)
      .use(statsRoutes)
  )

  // Vike SSR handler - must be last
  .get('/*', async ({ request }) => {
    const pageContextInit = { urlOriginal: request.url };
    const pageContext = await renderPage(pageContextInit);
    const { httpResponse } = pageContext;

    if (!httpResponse) {
      return new Response('Not found', { status: 404 });
    }

    const { readable, headers, statusCode } = httpResponse;
    return new Response(readable, {
      status: statusCode,
      headers: Object.fromEntries(headers)
    });
  })

  .listen(PORT);

console.log(`ðŸ¦Š Elysia server running at http://localhost:${PORT}`);

export type App = typeof app;
```

---

## 6. API ROUTE PATTERN

```typescript
// src/server/routes/feature.ts
import { Elysia, t } from 'elysia';
import { cache } from '../services/cache';

export const featureRoutes = new Elysia({ prefix: '/feature' })
  .get(
    '/:id',
    async ({ params, query }) => {
      const { id } = params;

      // Check cache
      const cacheKey = `feature:${id}`;
      const cached = cache.get<Data>(cacheKey);
      if (cached) {
        return { success: true, data: cached };
      }

      // Fetch data
      const data = await fetchData(id);

      // Cache it
      cache.set(cacheKey, data, 5 * 60);

      return { success: true, data };
    },
    {
      params: t.Object({
        id: t.String()
      }),
      query: t.Object({
        filter: t.Optional(t.String())
      })
    }
  )
  .post(
    '/',
    async ({ body }) => {
      const result = await createData(body);
      return { success: true, data: result };
    },
    {
      body: t.Object({
        name: t.String(),
        value: t.String()
      })
    }
  );
```

---

## 7. VIKE PAGE STRUCTURE

### Global Config
```typescript
// src/pages/+config.ts
import vikeReact from 'vike-react/config';
import type { Config } from 'vike/types';

export default {
  extends: [vikeReact],
  ssr: true,
  clientRouting: true
} satisfies Config;
```

### Global Layout
```typescript
// src/pages/+Layout.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReportProvider } from '../contexts/ReportContext';
import { Box } from 'styled-system/jsx';
import type { ReactNode } from 'react';
import '../index.css';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,
      refetchOnWindowFocus: false
    }
  }
});

export function Layout({ children }: { children: ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      <ReportProvider>
        <Box id="app">
          {children}
        </Box>
      </ReportProvider>
    </QueryClientProvider>
  );
}
```

### Page Component
```typescript
// src/pages/index/+Page.tsx
import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Box, VStack, HStack, Grid } from 'styled-system/jsx';
import { Button } from '~/components/ui/button';
import { useReport } from '~/contexts/ReportContext';

export default function Page() {
  const { userId } = useReport();
  const [selectedItem, setSelectedItem] = useState(null);

  const { data, isLoading, isError } = useQuery({
    queryKey: ['events', userId],
    queryFn: async () => {
      const res = await fetch(`/api/events/user/${userId}`);
      if (!res.ok) throw new Error('Failed to fetch');
      return res.json();
    },
    enabled: !!userId
  });

  if (isLoading) return <Box>Loading...</Box>;
  if (isError) return <Box>Error</Box>;

  return (
    <Box p={{ base: '4', md: '8' }}>
      <VStack gap="6" alignItems="stretch">
        <HStack justifyContent="space-between">
          <h1>Title</h1>
          <Button>Action</Button>
        </HStack>

        <Grid gap="4" columns={{ base: 1, md: 2, lg: 3 }}>
          {data?.map((item) => (
            <Box key={item.id} p="4" borderWidth="1px">
              {item.name}
            </Box>
          ))}
        </Grid>
      </VStack>
    </Box>
  );
}
```

---

## 8. CONTEXT PATTERN

```typescript
// src/contexts/FeatureContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react';

interface FeatureContextType {
  data: Data | null;
  setData: (data: Data) => void;
}

const FeatureContext = createContext<FeatureContextType | undefined>(undefined);

export function FeatureProvider({ children }: { children: ReactNode }) {
  const [data, setData] = useState<Data | null>(null);

  return (
    <FeatureContext.Provider value={{ data, setData }}>
      {children}
    </FeatureContext.Provider>
  );
}

export function useFeature() {
  const context = useContext(FeatureContext);
  if (!context) {
    throw new Error('useFeature must be used within FeatureProvider');
  }
  return context;
}
```

---

## 9. PANDACSS USAGE

```typescript
// Layout components
<VStack gap="4" alignItems="stretch">
  <Item />
</VStack>

<HStack gap="2" justifyContent="space-between">
  <Left />
  <Right />
</HStack>

<Grid columns={{ base: 1, md: 2, lg: 3 }} gap="4">
  <Card />
</Grid>

// Responsive props
<Box
  w={{ base: 'full', md: '50%' }}
  p={{ base: '2', md: '4' }}
>
  Content
</Box>

// Pseudo-selectors
<Box
  _hover={{ bg: 'bg.subtle' }}
  _active={{ transform: 'scale(0.95)' }}
>
  Interactive
</Box>

// Semantic tokens
bg="bg.default"
bg="bg.subtle"
color="fg.default"
color="fg.muted"
borderColor="border.default"
```

---

## 10. REACT QUERY PATTERNS

```typescript
// Query
const { data, isLoading, isError } = useQuery({
  queryKey: ['feature', param],
  queryFn: async () => {
    const res = await fetch(`/api/endpoint?param=${param}`);
    if (!res.ok) throw new Error('Failed');
    return res.json();
  },
  enabled: !!param
});

// Mutation
const mutation = useMutation({
  mutationFn: async (data: CreateData) => {
    const res = await fetch('/api/endpoint', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    if (!res.ok) throw new Error('Failed');
    return res.json();
  },
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['feature'] });
  }
});
```

---

## 11. MEMORY CACHE PATTERN

```typescript
// src/server/services/cache.ts
interface CacheEntry<T> {
  data: T;
  expiresAt: number;
}

class MemoryCache {
  private cache = new Map<string, CacheEntry<any>>();

  set<T>(key: string, value: T, ttlSeconds: number): void {
    this.cache.set(key, {
      data: value,
      expiresAt: Date.now() + ttlSeconds * 1000
    });
  }

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return null;
    }
    return entry.data as T;
  }

  cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiresAt) {
        this.cache.delete(key);
      }
    }
  }
}

export const cache = new MemoryCache();
setInterval(() => cache.cleanup(), 5 * 60 * 1000);
```

---

## 12. CRAWLER PATTERN (CRITICAL - USE EXACT SELECTORS)

```typescript
// src/server/crawlers/attendedEvents.ts
import { parseHTML } from 'linkedom';
import type { Event } from '../../shared/types/event';

export async function fetchAttendedEvents(
  userId: string,
  options: { limit?: number } = {}
): Promise<Event[]> {
  const url = `https://www.eventernote.com/users/${userId}/events?limit=${options.limit || 10000}`;

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const html = await response.text();
  const { document } = parseHTML(html);

  // Use exact selectors from reference implementation
  const eventElements = document.querySelectorAll(
    'body > div.container > div.row > div.span8.page > div.gb_event_list.clearfix > ul > li'
  );

  const events: Event[] = [];

  for (const element of eventElements) {
    const eventElement = element.querySelector('div.event > h4 > a');
    const dateElement = element.querySelector('div.date > p');
    const placeElement = element.querySelector('div.place > a');

    if (eventElement && dateElement && placeElement) {
      const href = eventElement.getAttribute('href');
      const name = eventElement.textContent?.trim();
      const date = dateElement.textContent?.trim();
      const place = placeElement.textContent?.trim();

      if (href && name && date && place) {
        events.push({ name, href, date, place });
      }
    }
  }

  return events;
}
```

---

## CRITICAL RULES

1. **ALWAYS use exact selectors from reference** - Don't guess or approximate
2. **Follow import order exactly** - Order matters for consistency
3. **Use join(__dirname, path) for Vite aliases** - Not relative paths
4. **Memory cache for all data** - Not database
5. **Elysia routes use t.Object() for validation** - Not Zod
6. **PandaCSS uses styled-system/jsx** - Import Box, VStack, etc
7. **React Query in all pages** - For data fetching
8. **Context + custom hook pattern** - Not Zustand
9. **Vike SSR route must be last** - In Elysia server
10. **Different port for each app** - Check reference ports

---

## WHEN IN DOUBT

1. Check CLAUDE.MD first
2. Look at reference project files
3. Copy exact patterns, don't approximate
4. Use exact selectors, don't guess
5. Follow exact file structure
